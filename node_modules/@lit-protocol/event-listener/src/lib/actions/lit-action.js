"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LitActionAction = void 0;
const constants_1 = require("@lit-protocol/constants");
const action_1 = require("./action");
const litActions_1 = require("../litActions");
class LitActionAction extends action_1.Action {
    constructor(params) {
        const litActionFunction = async () => {
            const activePkp = params.stateMachine.resolveContextPathOrLiteral({
                contextPath: 'activePkp',
            });
            if (!activePkp) {
                throw new constants_1.AutomationError({
                    info: {
                        machineId: params.stateMachine.id,
                        activePkp,
                    },
                }, `There is no active pkp. Must configure it to run a Lit Action`);
            }
            const litActionResponse = await (0, litActions_1.executeLitAction)({
                litNodeClient: params.stateMachine.litNodeClient,
                capacityTokenId: params.stateMachine.resolveContextPathOrLiteral({
                    contextPath: 'activeCapacityTokenId',
                }),
                pkpEthAddress: activePkp.ethAddress,
                pkpPublicKey: activePkp.publicKey,
                authSigner: params.stateMachine.signer,
                ipfsId: 'ipfsId' in params
                    ? params.stateMachine.resolveContextPathOrLiteral(params.ipfsId)
                    : undefined,
                code: 'code' in params
                    ? params.stateMachine.resolveContextPathOrLiteral(params.code)
                    : undefined,
                jsParams: params.jsParams,
            });
            // TODO send user this result with a webhook and log
            params.stateMachine.setToContext('lastLitActionResponse', litActionResponse);
        };
        super({
            debug: params.debug,
            function: litActionFunction,
        });
    }
}
exports.LitActionAction = LitActionAction;
//# sourceMappingURL=lit-action.js.map