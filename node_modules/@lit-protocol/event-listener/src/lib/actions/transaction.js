"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionAction = void 0;
const ethers_1 = require("ethers");
const constants_1 = require("@lit-protocol/constants");
const action_1 = require("./action");
const litActions_1 = require("../litActions");
const chain_1 = require("../utils/chain");
function arrayfy(value) {
    return Array.isArray(value) ? value : [value];
}
class TransactionAction extends action_1.Action {
    constructor(params) {
        const litActionFunction = async () => {
            const activePkp = params.stateMachine.resolveContextPathOrLiteral({
                contextPath: 'activePkp',
            });
            if (!activePkp.ethAddress) {
                throw new constants_1.AutomationError({
                    info: {
                        machineId: params.stateMachine.id,
                        activePkp,
                    },
                }, `There is no active pkp. Must configure it to run a transaction`);
            }
            // Resolve transaction data from context
            const txChainId = params.stateMachine.resolveContextPathOrLiteral(params.evmChainId);
            const chain = (0, chain_1.getEvmChain)(txChainId);
            const chainProvider = new ethers_1.ethers.providers.JsonRpcProvider(chain.rpcUrls[0], chain.chainId);
            const txContractAddress = params.stateMachine.resolveContextPathOrLiteral(params.contractAddress);
            const txValue = params.stateMachine.resolveContextPathOrLiteral(params.value);
            // transaction can have data or the fields necessary to populate it
            let txData;
            if (!('contractABI' in params)) {
                txData = params.stateMachine.resolveContextPathOrLiteral(params.data);
            }
            else {
                const txMethod = params.stateMachine.resolveContextPathOrLiteral(params.method);
                const txParams = arrayfy(!Array.isArray(params.params)
                    ? params.stateMachine.resolveContextPathOrLiteral(params.params)
                    : params.params.map(params.stateMachine.resolveContextPathOrLiteral.bind(params.stateMachine)));
                const contract = new ethers_1.ethers.Contract(txContractAddress, params.contractABI, chainProvider);
                const populatedTx = await contract.populateTransaction[txMethod](...txParams);
                txData = populatedTx.data;
            }
            const gasLimit = await chainProvider.estimateGas({
                to: txContractAddress,
                data: txData,
                from: activePkp.ethAddress,
            });
            const gasPrice = await chainProvider.getGasPrice();
            const nonce = await chainProvider.getTransactionCount(activePkp.ethAddress);
            const rawTx = {
                chainId: chain.chainId,
                data: txData,
                gasLimit: gasLimit.toHexString(),
                gasPrice: gasPrice.toHexString(),
                nonce,
                to: txContractAddress,
                value: txValue,
            };
            const rawTxHash = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.serializeTransaction(rawTx));
            // Sign with the PKP in a LitAction
            const yellowstoneMachineSigner = params.stateMachine.signer;
            const litActionResponse = await (0, litActions_1.executeLitAction)({
                litNodeClient: params.stateMachine.litNodeClient,
                capacityTokenId: params.stateMachine.resolveContextPathOrLiteral({
                    contextPath: 'activeCapacityTokenId',
                }),
                pkpEthAddress: activePkp.ethAddress,
                pkpPublicKey: activePkp.publicKey,
                authSigner: yellowstoneMachineSigner,
                code: litActions_1.signWithLitActionCode,
                jsParams: {
                    toSign: ethers_1.ethers.utils.arrayify(rawTxHash),
                    publicKey: activePkp.publicKey,
                    sigName: 'signedTransaction',
                },
            });
            if (!litActionResponse.success) {
                throw new constants_1.AutomationError({
                    info: {
                        machineId: params.stateMachine.id,
                        evmChainId: params.evmChainId,
                        contractAddress: params.contractAddress,
                        value: params.value,
                        data: 'data' in params ? params.data : undefined,
                        contractABI: 'contractABI' in params ? params.contractABI : undefined,
                        method: 'method' in params ? params.method : undefined,
                        params: 'params' in params ? params.params : undefined,
                        logs: litActionResponse.logs,
                    },
                }, `Failed to sign transaction`);
            }
            const signature = litActionResponse.response;
            const jsonSignature = JSON.parse(signature);
            jsonSignature.r = '0x' + jsonSignature.r.substring(2);
            jsonSignature.s = '0x' + jsonSignature.s;
            const hexSignature = ethers_1.ethers.utils.joinSignature(jsonSignature);
            const signedTx = ethers_1.ethers.utils.serializeTransaction(rawTx, hexSignature);
            const receipt = await chainProvider.sendTransaction(signedTx);
            // TODO send user this result with a webhook and log
            params.stateMachine.setToContext('lastTransactionReceipt', receipt);
        };
        super({
            debug: params.debug,
            function: litActionFunction,
        });
    }
}
exports.TransactionAction = TransactionAction;
//# sourceMappingURL=transaction.js.map