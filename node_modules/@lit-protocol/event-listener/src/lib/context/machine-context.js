"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MachineContext = void 0;
function parsePath(path) {
    if (!path)
        return [];
    if (Array.isArray(path))
        return path;
    // Match either dot notation or array notation: foo.bar[0].baz or ['foo', 'bar', '0', 'baz']
    return path.split(/\.|\[|\]/).filter(Boolean);
}
function getFromObject(object, path) {
    if (!path)
        return object;
    const parts = parsePath(path);
    return parts.reduce((obj, key) => {
        const index = parseInt(key);
        if (!isNaN(index) && Array.isArray(obj)) {
            return obj[index];
        }
        return obj?.[key];
    }, object);
}
class MachineContext {
    constructor(initialContext) {
        this.context = {};
        this.context = initialContext ?? {};
    }
    get(path) {
        return getFromObject(this.context, path);
    }
    set(path, value = undefined) {
        const parts = parsePath(path);
        let current = this.context;
        for (let i = 0; i < parts.length; i++) {
            const key = parts[i];
            const isLast = i === parts.length - 1;
            const index = parseInt(key);
            if (!isNaN(index)) {
                if (Array.isArray(current)) {
                    if (isLast) {
                        current[index] = value;
                    }
                    else {
                        current[index] =
                            current[index] ?? (isNaN(parseInt(parts[i + 1])) ? {} : []);
                        current = current[index];
                    }
                }
                else {
                    if (isLast) {
                        current[key] = value;
                    }
                    else {
                        current[key] =
                            current[key] ?? (isNaN(parseInt(parts[i + 1])) ? {} : []);
                        current = current[key];
                    }
                }
            }
            else {
                if (isLast) {
                    current[key] = value;
                }
                else {
                    current = current[key] =
                        current[key] ?? (isNaN(parseInt(parts[i + 1])) ? {} : []);
                }
            }
        }
    }
    push(path, value) {
        const currentValue = this.get(path);
        if (currentValue === undefined) {
            this.set(path, [value]);
        }
        else if (Array.isArray(currentValue)) {
            currentValue.push(value);
        }
        else {
            this.set(path, [currentValue, value]);
        }
    }
    setFromData(location, data, path) {
        if (!data)
            return;
        const value = getFromObject(data, path);
        this.set(location, value);
    }
}
exports.MachineContext = MachineContext;
//# sourceMappingURL=machine-context.js.map