import { ethers } from 'ethers';
import { LitContracts } from '@lit-protocol/contracts-sdk';
import { LitNodeClient } from '@lit-protocol/lit-node-client';
import { StateParams } from './states';
import { BaseStateMachineParams, ContextOrLiteral, StateDefinition, StateMachineDefinition, TransitionDefinition, TransitionParams, voidAsyncFunction } from './types';
export type MachineStatus = 'running' | 'stopped';
export declare const StateMachineInitialContext: Readonly<{
    activeCapacityTokenId: undefined;
    activePkp: undefined;
}>;
/**
 * A StateMachine class that manages states and transitions between them.
 */
export declare class StateMachine {
    private readonly debug;
    private readonly onError?;
    private context;
    readonly litNodeClient: LitNodeClient;
    private readonly privateKey?;
    litContracts: LitContracts;
    id: string;
    status: MachineStatus;
    private states;
    private transitions;
    private currentState?;
    private onStopCallback?;
    constructor(params: BaseStateMachineParams);
    static fromDefinition(machineConfig: StateMachineDefinition): StateMachine;
    /**
     * Indicates if the state machine is running
     */
    get isRunning(): boolean;
    /**
     * Returns an ethers Wallet the state machine can use
     */
    get signer(): ethers.Wallet;
    /**
     * Adds a custom state to the state machine.
     * @param params The parameters for the state.
     */
    addState(params: StateParams): void;
    /**
     * Adds a state to the state machine using the declarative interface.
     * @param stateDefinition The state definition.
     */
    addStateFromDefinition(stateDefinition: StateDefinition): void;
    /**
     * Adds a transition between two states.
     * @param params The parameters for the transition.
     */
    addTransition({ actions, fromState, toState, listeners, check, onMatch, onMismatch, }: TransitionParams): void;
    addTransitionFromDefinition(transitionDefinition: TransitionDefinition): void;
    /**
     * Starts the state machine with the given initial state.
     * @param initialState The key of the initial state.
     * @param onStop Optional callback to execute when the machine is stopped.
     */
    startMachine(initialState: string, onStop?: voidAsyncFunction): Promise<void>;
    /**
     * Gets a value from the machine context
     * If value or path do not exist it returns undefined
     * @param path the context path to read
     */
    getFromContext<T>(path?: string | string[]): T;
    /**
     * Resolves a value from the context if it specifies a path or returns it as a literal
     * @param value the literal value or read context object
     */
    resolveContextPathOrLiteral<T = unknown>(value: ContextOrLiteral<T> | T): T;
    /**
     * Sets a value in the machine context
     * If path does not exist, it is created
     * @param path the context path to write
     * @param value the value to write in the context path
     */
    setToContext(path: string | string[], value: unknown): void;
    /**
     * Pushes a value in the machine context. The value will be converted to an array if it is not
     * If path does not exist, it is created
     * @param path the context path to write
     * @param value the value to write in the context path
     */
    pushToContext(path: string | string[], value: unknown): void;
    /**
     * Stops the state machine by exiting the current state and not moving to another one.
     */
    stopMachine(): Promise<void>;
    /**
     * Stops listening on the current state's transitions and exits the current state.
     */
    private exitCurrentState;
    /**
     * Moves to a new state.
     * @param stateKey The key of the new state.
     */
    private enterState;
    /**
     * Triggers a transition to a new state.
     * @param stateKey The key of the target state.
     */
    private transitionTo;
    /**
     * Merges the given action definitions into a single function that executes all actions concurrently.
     * @param actionDefinitions
     * @returns A function that executes all actions concurrently.
     * @private
     */
    private mergeActions;
    /**
     * Handles errors in the state machine.
     * @param error
     * @param context
     * @private
     */
    private handleError;
    /**
     * Generates a unique identifier for the state machine.
     * @returns A unique identifier string.
     * @private
     */
    private generateId;
}
