"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateMachine = exports.StateMachineInitialContext = void 0;
const ethers_1 = require("ethers");
const constants_1 = require("@lit-protocol/constants");
const contracts_sdk_1 = require("@lit-protocol/contracts-sdk");
const lit_node_client_1 = require("@lit-protocol/lit-node-client");
const actions_1 = require("./actions");
const machine_context_1 = require("./context/machine-context");
const listeners_1 = require("./listeners");
const states_1 = require("./states");
const transitions_1 = require("./transitions");
const chain_1 = require("./utils/chain");
const erc20_1 = require("./utils/erc20");
exports.StateMachineInitialContext = Object.freeze({
    activeCapacityTokenId: undefined,
    activePkp: undefined,
});
/**
 * A StateMachine class that manages states and transitions between them.
 */
class StateMachine {
    constructor(params) {
        this.status = 'stopped';
        this.states = new Map();
        this.transitions = new Map();
        this.id = this.generateId();
        this.debug = params.debug ?? false;
        this.onError = params.onError;
        this.context = new machine_context_1.MachineContext({
            ...exports.StateMachineInitialContext,
            ...params.context,
        });
        this.litNodeClient = params.litNodeClient;
        this.litContracts = params.litContracts;
        this.privateKey = params.privateKey;
    }
    static fromDefinition(machineConfig) {
        const { debug = false, context, onError, litContracts = {}, litNodeClient, privateKey, states = [], transitions = [], } = machineConfig;
        // Create litNodeClient and litContracts instances
        const litNodeClientInstance = 'connect' in litNodeClient
            ? litNodeClient
            : new lit_node_client_1.LitNodeClient(litNodeClient);
        const litContractsInstance = 'connect' in litContracts
            ? litContracts
            : new contracts_sdk_1.LitContracts({
                privateKey,
                ...litContracts,
            });
        if (litNodeClientInstance.config.litNetwork !== litContractsInstance.network) {
            throw new constants_1.AutomationError({
                info: {
                    litNodeClientNetwork: litNodeClientInstance.config.litNetwork,
                    litContractsNetwork: litContractsInstance.network,
                },
            }, 'litNodeClient and litContracts should not use different networks');
        }
        const stateMachine = new StateMachine({
            debug,
            context,
            litNodeClient: litNodeClientInstance,
            litContracts: litContractsInstance,
            privateKey,
            onError,
        });
        const stateTransitions = [];
        states.forEach((stateDefinition) => {
            const transitions = stateDefinition.transitions || [];
            stateTransitions.push(...transitions.map((transition) => ({
                ...transition,
                fromState: stateDefinition.key,
            })));
            stateMachine.addStateFromDefinition(stateDefinition);
        });
        [...stateTransitions, ...transitions].forEach((transition) => {
            stateMachine.addTransitionFromDefinition(transition);
        });
        return stateMachine;
    }
    /**
     * Indicates if the state machine is running
     */
    get isRunning() {
        return this.status === 'running';
    }
    /**
     * Returns an ethers Wallet the state machine can use
     */
    get signer() {
        if (!this.privateKey) {
            throw new constants_1.AutomationError({
                info: {},
            }, `Cannot use state machine signer without a private key. Pass a PK to the machine when creating it`);
        }
        return new ethers_1.ethers.Wallet(this.privateKey, new ethers_1.ethers.providers.JsonRpcProvider(constants_1.RPC_URL_BY_NETWORK[this.litNodeClient.config.litNetwork]));
    }
    /**
     * Adds a custom state to the state machine.
     * @param params The parameters for the state.
     */
    addState(params) {
        const state = new states_1.State(params);
        this.states.set(state.key, state);
        if (!this.transitions.has(state.key)) {
            this.transitions.set(state.key, new Map());
        }
    }
    /**
     * Adds a state to the state machine using the declarative interface.
     * @param stateDefinition The state definition.
     */
    addStateFromDefinition(stateDefinition) {
        const stateParams = {
            key: stateDefinition.key,
            debug: this.debug,
        };
        // Merge all state actions
        const { actions = [] } = stateDefinition;
        stateParams.onEnter = this.mergeActions(actions);
        this.addState(stateParams);
    }
    /**
     * Adds a transition between two states.
     * @param params The parameters for the transition.
     */
    addTransition({ actions = [], fromState, toState, listeners, check, onMatch, onMismatch, }) {
        if (!this.states.has(fromState)) {
            throw new constants_1.AutomationError({
                info: {
                    machineId: this.id,
                    fromState: fromState,
                    toState: toState,
                },
            }, `Source state ${fromState} not found`);
        }
        if (!this.states.has(toState)) {
            throw new constants_1.AutomationError({
                info: {
                    machineId: this.id,
                    fromState: fromState,
                    toState: toState,
                },
            }, `Target state ${toState} not found`);
        }
        const transitioningOnMatch = async (values) => {
            await this.mergeActions(actions)();
            await onMatch?.(values);
            await this.transitionTo(toState);
        };
        const onTransitionError = async (error) => {
            this.handleError(error, `Error at ${fromState} -> ${toState} transition`);
        };
        const transition = new transitions_1.Transition({
            debug: this.debug,
            listeners,
            check,
            onError: onTransitionError,
            onMatch: transitioningOnMatch,
            onMismatch,
        });
        const stateTransitions = this.transitions.get(fromState) ?? new Map();
        stateTransitions.set(toState, transition);
        this.transitions.set(fromState, stateTransitions);
    }
    addTransitionFromDefinition(transitionDefinition) {
        const { actions, balances, evmContractEvent, fromState, timer, toState } = transitionDefinition;
        const transitionConfig = {
            actions,
            fromState,
            toState,
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Listeners can be any type
        const listeners = [];
        const checks = [];
        if (timer) {
            const transitionIndex = checks.length;
            listeners.push(new listeners_1.TimerListener(timer.interval, timer.offset, timer.step));
            checks.push(async (values) => values[transitionIndex] === timer.until);
        }
        if (evmContractEvent) {
            const transitionIndex = checks.length;
            const chainId = this.resolveContextPathOrLiteral(evmContractEvent.evmChainId);
            const chain = (0, chain_1.getEvmChain)(chainId);
            listeners.push(new listeners_1.EVMContractEventListener(chain.rpcUrls[0], {
                address: evmContractEvent.contractAddress,
                abi: evmContractEvent.contractABI,
            }, {
                name: evmContractEvent.eventName,
                filter: evmContractEvent.eventParams,
            }));
            checks.push(async (values) => {
                const eventData = values[transitionIndex];
                evmContractEvent.contextUpdates?.forEach((contextUpdate) => this.context.setFromData(contextUpdate.contextPath, eventData, contextUpdate.dataPath));
                return eventData?.event.event === evmContractEvent.eventName;
            });
        }
        if (balances) {
            balances.forEach((balance) => {
                const transitionIndex = checks.length;
                const chainId = this.resolveContextPathOrLiteral(balance.evmChainId);
                const chain = (0, chain_1.getEvmChain)(chainId);
                const chainProvider = new ethers_1.ethers.providers.JsonRpcProvider(chain.rpcUrls[0], chain.chainId);
                switch (balance.type) {
                    case 'native':
                        listeners.push(new listeners_1.IntervalListener(() => chainProvider.getBalance(balance.address), balance.interval));
                        checks.push((0, erc20_1.getBalanceTransitionCheck)(transitionIndex, balance));
                        break;
                    case 'ERC20':
                        listeners.push(new listeners_1.IntervalListener(() => (0, erc20_1.getERC20Balance)(chainProvider, balance.tokenAddress, balance.tokenDecimals, balance.address), balance.interval));
                        checks.push((0, erc20_1.getBalanceTransitionCheck)(transitionIndex, balance));
                        break;
                    // case 'ERC721':
                    // case 'ERC1155':
                    default:
                        throw new constants_1.AutomationError({
                            info: {
                                machineId: this.id,
                                balance,
                            },
                        }, `TODO balance check type ${balance['type']} unknown or not yet implemented`);
                }
            });
        }
        // Add all listeners to the transition
        transitionConfig.listeners = listeners;
        // Aggregate (AND) all listener checks to a single function result
        transitionConfig.check = async (values) => {
            this.debug &&
                console.log(`${transitionDefinition.fromState} -> ${transitionDefinition.toState} values`, values);
            return Promise.all(checks.map((check) => check(values))).then((results) => {
                this.debug &&
                    console.log(`${transitionDefinition.fromState} -> ${transitionDefinition.toState} results`, results);
                return results.every((result) => result);
            });
        };
        this.addTransition(transitionConfig);
    }
    /**
     * Starts the state machine with the given initial state.
     * @param initialState The key of the initial state.
     * @param onStop Optional callback to execute when the machine is stopped.
     */
    async startMachine(initialState, onStop) {
        this.debug && console.log('Starting state machine...');
        await Promise.all([
            this.litContracts.connect(),
            this.litNodeClient.connect(),
        ]);
        this.onStopCallback = onStop;
        await this.enterState(initialState);
        this.status = 'running';
        this.debug && console.log('State machine started');
    }
    /**
     * Gets a value from the machine context
     * If value or path do not exist it returns undefined
     * @param path the context path to read
     */
    getFromContext(path) {
        return this.context.get(path);
    }
    /**
     * Resolves a value from the context if it specifies a path or returns it as a literal
     * @param value the literal value or read context object
     */
    resolveContextPathOrLiteral(value) {
        if (value && typeof value === 'object' && 'contextPath' in value) {
            return this.context.get(value.contextPath);
        }
        return value;
    }
    /**
     * Sets a value in the machine context
     * If path does not exist, it is created
     * @param path the context path to write
     * @param value the value to write in the context path
     */
    setToContext(path, value) {
        this.context.set(path, value);
    }
    /**
     * Pushes a value in the machine context. The value will be converted to an array if it is not
     * If path does not exist, it is created
     * @param path the context path to write
     * @param value the value to write in the context path
     */
    pushToContext(path, value) {
        this.context.push(path, value);
    }
    /**
     * Stops the state machine by exiting the current state and not moving to another one.
     */
    async stopMachine() {
        this.debug && console.log('Stopping state machine...');
        this.status = 'stopped';
        await this.exitCurrentState();
        await this.onStopCallback?.();
        this.debug && console.log('State machine stopped');
    }
    /**
     * Stops listening on the current state's transitions and exits the current state.
     */
    async exitCurrentState() {
        this.debug && console.log('exitCurrentState', this.currentState?.key);
        const currentTransitions = this.transitions.get(this.currentState?.key ?? '') ??
            new Map();
        await Promise.all(Array.from(currentTransitions.values()).map((t) => t.stopListening()));
        await this.currentState?.exit();
        this.currentState = undefined;
    }
    /**
     * Moves to a new state.
     * @param stateKey The key of the new state.
     */
    async enterState(stateKey) {
        const state = this.states.get(stateKey);
        if (!state) {
            throw new constants_1.AutomationError({
                info: {
                    machineId: this.id,
                    state: stateKey,
                    currentState: this.currentState,
                    isRunning: this.isRunning,
                },
            }, `State ${stateKey} not found`);
        }
        this.debug && console.log('enterState', state.key);
        await state.enter();
        const nextTransitions = this.transitions.get(state.key) ?? new Map();
        await Promise.all(Array.from(nextTransitions.values()).map((t) => t.startListening()));
        this.currentState = state;
    }
    /**
     * Triggers a transition to a new state.
     * @param stateKey The key of the target state.
     */
    async transitionTo(stateKey) {
        const nextState = this.states.get(stateKey);
        if (!nextState) {
            throw new constants_1.UnknownError({
                machineId: this.id,
                currentState: this.currentState,
                nextState: stateKey,
            }, `Machine next state not found`);
        }
        if (this.currentState === nextState) {
            console.warn(`State ${stateKey} is already active. Skipping state change.`);
            return;
        }
        try {
            // Machine consumer can call stopMachine() while we are in the middle of a transition
            this.isRunning && (await this.exitCurrentState());
            this.isRunning && (await this.enterState(stateKey));
        }
        catch (e) {
            this.currentState = undefined;
            this.handleError(e, `Could not enter state ${stateKey}`);
        }
    }
    /**
     * Merges the given action definitions into a single function that executes all actions concurrently.
     * @param actionDefinitions
     * @returns A function that executes all actions concurrently.
     * @private
     */
    mergeActions(actionDefinitions) {
        const actions = [];
        actionDefinitions.forEach((action) => {
            switch (action.key) {
                case 'context':
                    if (typeof action.log?.path === 'string') {
                        actions.push(new actions_1.LogContextAction({
                            debug: this.debug,
                            stateMachine: this,
                            path: action.log.path,
                        }));
                    }
                    break;
                case 'litAction':
                    actions.push(new actions_1.LitActionAction({
                        debug: this.debug,
                        stateMachine: this,
                        ...action,
                    }));
                    break;
                case 'transaction':
                    actions.push(new actions_1.TransactionAction({
                        debug: this.debug,
                        stateMachine: this,
                        ...action,
                    }));
                    break;
                case 'useCapacityNFT':
                    if ('capacityTokenId' in action) {
                        this.context.set('activeCapacityTokenId', this.resolveContextPathOrLiteral(action.capacityTokenId));
                    }
                    else if ('mint' in action) {
                        const mintCapacityCreditAction = new actions_1.MintCapacityCreditAction({
                            daysUntilUTCMidnightExpiration: action.daysUntilUTCMidnightExpiration,
                            debug: this.debug,
                            requestPerSecond: action.requestPerSecond,
                            stateMachine: this,
                        });
                        actions.push(mintCapacityCreditAction);
                    }
                    if (this.debug) {
                        const activeCapacityTokenId = this.context.get('activePkp');
                        console.log(`Machine configured to use capacity token ${activeCapacityTokenId}`);
                    }
                    break;
                case 'usePkp':
                    if ('pkp' in action) {
                        this.context.set('activePkp', this.resolveContextPathOrLiteral(action.pkp));
                    }
                    else if ('mint' in action) {
                        const mintPkpAction = new actions_1.MintPkpAction({
                            debug: this.debug,
                            stateMachine: this,
                        });
                        actions.push(mintPkpAction);
                    }
                    if (this.debug) {
                        const activePkp = this.context.get('activePkp');
                        console.log(`Machine configured to use pkp ${activePkp}`);
                    }
                    break;
                default:
                    throw new constants_1.AutomationError({
                        info: {
                            action,
                        },
                    }, `Unknown action. Check error info.`);
            }
        });
        return async () => {
            await Promise.all(actions.map((action) => action.run())).catch((err) => {
                this.handleError(err, `Error running actions. Check details.`);
            });
        };
    }
    /**
     * Handles errors in the state machine.
     * @param error
     * @param context
     * @private
     */
    handleError(error, context) {
        // Try to halt machine if it is still running
        if (this.isRunning) {
            const publicError = new constants_1.AutomationError({
                info: {
                    stateMachineId: this.id,
                    status: this.status,
                    currentState: this.currentState,
                },
                cause: error,
            }, context ?? 'Error running state machine');
            if (this.onError) {
                this.onError(publicError);
            }
            else {
                // This throw will likely crash the server
                throw publicError;
            }
            // Throwing when stopping could hide above error
            this.stopMachine().catch(console.error);
        }
    }
    /**
     * Generates a unique identifier for the state machine.
     * @returns A unique identifier string.
     * @private
     */
    generateId() {
        return Math.random().toString(36).substring(2);
    }
}
exports.StateMachine = StateMachine;
//# sourceMappingURL=state-machine.js.map