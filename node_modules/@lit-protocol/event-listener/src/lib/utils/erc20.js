"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC20ABI = void 0;
exports.getERC20Balance = getERC20Balance;
exports.getBalanceTransitionCheck = getBalanceTransitionCheck;
const ethers_1 = require("ethers");
exports.ERC20ABI = [
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address',
            },
        ],
        name: 'balanceOf',
        outputs: [
            {
                name: 'balance',
                type: 'uint256',
            },
        ],
        payable: false,
        type: 'function',
    },
];
async function getERC20Balance(provider, tokenAddress, tokenDecimals, accountAddress) {
    const contract = new ethers_1.ethers.Contract(tokenAddress, exports.ERC20ABI, provider);
    const balance = (await contract['balanceOf'](accountAddress));
    const adjustedBalance = ethers_1.ethers.utils.parseUnits(balance.toString(), 18 - tokenDecimals);
    return adjustedBalance;
}
function getBalanceTransitionCheck(transitionIndex, balance) {
    const balanceCheck = async (values) => {
        const { amount, comparator } = balance;
        const targetAmount = ethers_1.ethers.utils.parseUnits(amount);
        const addressBalance = values[transitionIndex];
        if (!addressBalance)
            return false;
        switch (comparator) {
            case '<':
                return addressBalance.lt(targetAmount);
            case '<=':
                return addressBalance.lte(targetAmount);
            case '=':
                return addressBalance.eq(targetAmount);
            case '!=':
                return !addressBalance.eq(targetAmount);
            case '>=':
                return addressBalance.gte(targetAmount);
            case '>':
                return addressBalance.gt(targetAmount);
            default:
                throw new Error(`Unrecognized comparator ${comparator}`);
        }
    };
    return balanceCheck;
}
//# sourceMappingURL=erc20.js.map